<!DOCTYPE html>
<html lang="pt-BR">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>sensor.log</title>
    <link
      href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css"
      rel="stylesheet"
      integrity="sha384-9ndCyUaIbzAi2FUVXJi0CjmCapSmO7SnpJef0486qhLnuZ2cdeRhO02iuK6FUUVM"
      crossorigin="anonymous"
    />
    <link rel="icon" type="image/x-icon" href="favicon.ico" />
  </head>

  <body>
    <script
      src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"
      integrity="sha384-geWF76RCwLtnZ8qwWowPQNguL3RmwHVBC9FhGdlKrxdiJJigb/j/68SIy3Te4Bkz"
      crossorigin="anonymous"
    ></script>
    <script
      src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.11.8/dist/umd/popper.min.js"
      integrity="sha384-I7E8VVD/ismYTF4hNIPjVp/Zjvgyol6VFvRkX/vR+Vc4jQkC+hVqc2pM8ODewa9r"
      crossorigin="anonymous"
    ></script>
    <script
      src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.min.js"
      integrity="sha384-fbbOQedDUMZZ5KreZpsbe1LCZPVmfTnH7ois6mU1QK+m14rQ1l2bGBq41eYeM/fS"
      crossorigin="anonymous"
    ></script>
    <script
      src="https://cdn.jsdelivr.net/npm/chart.js@3.9.1/dist/chart.min.js"
      integrity="sha256-+8RZJua0aEWg+QVVKg4LEzEEm/8RFez5Tb4JBNiV5xA="
      crossorigin="anonymous"
    ></script>
    <script
      src="https://cdn.jsdelivr.net/npm/hammerjs@2.0.8/hammer.min.js"
      integrity="sha256-eVNjHw5UeU0jUqPPpZHAkU1z4U+QFBBY488WvueTm88="
      crossorigin="anonymous"
    ></script>
    <script
      src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom@1.2.1/dist/chartjs-plugin-zoom.min.js"
      integrity="sha256-cRtVj62HOT1M3EGc+4EBacU/38hYsYrNBB48zEVn8uU="
      crossorigin="anonymous"
    ></script>
    <script
      src="https://cdn.jsdelivr.net/npm/luxon@3.0.4/build/global/luxon.min.js"
      integrity="sha256-APLcdSn5AMXqZzoKhlczWWyV93oXBTrfkjhqtMX8vEM="
      crossorigin="anonymous"
    ></script>
    <script
      src="https://cdn.jsdelivr.net/npm/chartjs-adapter-luxon@1.2.0/dist/chartjs-adapter-luxon.min.js"
      integrity="sha256-Mr694q2aTwUcDLulItPTrQjIMjDiW+LexQCdFT/iubY="
      crossorigin="anonymous"
    ></script>
    <script>
      var g_chartUpdate;

      var g_max_date = undefined;
      var g_min_date = undefined;

      const g_default_sensor = [
        {
          parse: { key: "N√≠vel:" },
          chart: {
            hidden: false,
            label: "N√≠vel(%)",
            borderColor: "#37C",
            type: "line",
          },
        },
        {
          parse: { key: "Dist‚Çç‚ÇÄ‚Çé:" },
          chart: {
            hidden: true,
            label: "Dist‚Çç‚ÇÄ‚Çé(mm)",
            borderColor: "#037",
            type: "line",
          },
        },
        {
          parse: { key: "Dist‚Çç‚Çã‚ÇÅ‚Çé:" },
          chart: {
            hidden: true,
            label: "Dist‚Çç‚Çã‚ÇÅ‚Çé(mm)",
            borderColor: "#7CF",
            type: "line",
          },
        },
        {
          parse: { key: "Dist‚Çç‚Çã‚ÇÇ‚Çé:" },
          chart: {
            hidden: true,
            label: "Dist‚Çç‚Çã‚ÇÇ‚Çé(mm)",
            borderColor: "#F73",
            type: "line",
          },
        },
        {
          parse: { key: "Œîd/Œît‚Çç‚Çã‚ÇÅ‚Çé:" },
          chart: {
            hidden: true,
            label: "Œîd/Œît‚Çç‚Çã‚ÇÅ‚Çé(mm/h)",
            borderColor: "#C73",
            type: "line",
          },
        },
        {
          parse: { key: "Œîd/Œît‚Çç‚Çã‚ÇÇ‚Çé:" },
          chart: {
            hidden: true,
            label: "Œîd/Œît‚Çç‚Çã‚ÇÇ‚Çé(mm/h)",
            borderColor: "#FC7",
            type: "line",
          },
        },
        {
          parse: { key: "T0:" },
          chart: {
            hidden: true,
            label: "T0(¬∞C)",
            borderColor: "#37F",
            type: "line",
          },
        },
        {
          parse: { key: "T1:" },
          chart: {
            hidden: true,
            label: "T1(¬∞C)",
            borderColor: "#777",
            type: "line",
          },
        },
        {
          parse: { key: "V0:" },
          chart: {
            hidden: true,
            label: "V0(mV)",
            borderColor: "#F00",
            type: "line",
          },
        },
        {
          parse: { key: "V1:" },
          chart: {
            hidden: true,
            label: "V1(mV)",
            borderColor: "#700",
            type: "line",
          },
        },
        {
          parse: { key: "SNR:" },
          chart: {
            hidden: true,
            label: "SNR(dB)",
            borderColor: "#0F0",
            type: "line",
          },
        },
        {
          parse: { key: "RSSI:" },
          chart: {
            hidden: true,
            label: "RSSI(dB)",
            borderColor: "#070",
            type: "line",
          },
        },
        {
          parse: { key: "SNR(gw):" },
          chart: {
            hidden: true,
            label: "SNR(gw)(dB)",
            borderColor: "#0FF",
            type: "line",
          },
        },
        {
          parse: { key: "RSSI(gw):" },
          chart: {
            hidden: true,
            label: "RSSI(gw)(dB)",
            borderColor: "#F0F",
            type: "line",
          },
        },
      ];

      function calculePercent(val) {
        try {
          const mm_htmlMillimeter = document.getElementById("mmMillimeter");
          const mm_htmlOffset = document.getElementById("mmOffset");
          const mm_htmlBottom = document.getElementById("mmBottom");
          const mm_htmlPercent = document.getElementById("mmPercent");

          let mm = Number(mm_htmlMillimeter.value);
          let offset = Number(mm_htmlOffset.value);
          let bottom = Number(mm_htmlBottom.value);
          let percent = (1 - (mm - offset) / (bottom - offset)) * 100;
          mm_htmlPercent.value = percent.toFixed(1);
        } catch (error) {
          console.error(error);
        }
      }
      function calculeMillimeter(val) {
        try {
          const p_htmlMillimeter = document.getElementById("pMillimeter");
          const p_htmlOffset = document.getElementById("pOffset");
          const p_htmlBottom = document.getElementById("pBottom");
          const p_htmlPercent = document.getElementById("pPercent");

          let percent = Number(p_htmlPercent.value);
          let offset = Number(p_htmlOffset.value);
          let bottom = Number(p_htmlBottom.value);
          let mm = (1 - percent / 100) * (bottom - offset) + offset;
          p_htmlMillimeter.value = mm.toFixed(0);
        } catch (error) {
          console.error(error);
        }
      }

      function pushValue(sensor_data, bot_name, sensor, index, value) {
        if (!sensor_data.includes(bot_name)) {
          sensor_data.push(bot_name);
          sensor_data[bot_name] = [];
        }
        if (!sensor_data[bot_name].includes(sensor)) {
          sensor_data[bot_name].push(sensor);
          sensor_data[bot_name][sensor] = [];
          g_default_sensor.forEach((item) => {
            sensor_data[bot_name][sensor].push([]);
          });
        }
        sensor_data[bot_name][sensor][index].push(value);
      }

      function registerDate(date) {
        if (typeof g_max_date !== "number" || date > g_max_date) {
          g_max_date = date;
        }
        if (typeof g_min_date !== "number" || date < g_min_date) {
          g_min_date = date;
        }
      }

      function updateDateSelector(pDataInicial, pDataFinal) {
        const offset = new Date().getTimezoneOffset() * 60 * 1000;
        if (typeof g_min_date === "number") {
          pDataInicial.value = new Date(g_min_date - offset).toISOString().split(".")[0];
        } else {
          pDataInicial.value = "";
        }
        if (typeof g_max_date === "number") {
          pDataFinal.value = new Date(g_max_date - offset).toISOString().split(".")[0];
        } else {
          pDataFinal.value = "";
        }
      }

      class ChartUpdate {
        #index_;
        #chart_;
        #data_;
        constructor(data, chart) {
          this.index_ = 0;
          this.chart_ = chart;
          this.data_ = data;
          this.update();
        }
        title() {
          return this.chart_.options.plugins.title.text;
        }
        zoom(x_min, x_max) {
          this.chart_.options.scales.x.min = x_min;
          this.chart_.options.scales.x.max = x_max;
          this.chart_.update();
          this.resetZoom();
        }
        resetZoom() {
          this.chart_.resetZoom();
        }
        update() {
          let length = this.length();
          if (length) {
            this.index_ += length;
            this.index_ %= length;
            this.chart_.data.datasets = this.data_[this.index_].datasets;
            this.chart_.options.plugins.title.text = this.data_[this.index_].title;
            this.chart_.update();
          }
        }
        next() {
          this.index_++;
          this.update();
        }
        prev() {
          this.index_--;
          this.update();
        }
        position(position) {
          this.index_ = position;
          this.update();
        }
        length() {
          return this.data_.length;
        }
      }

      Chart.Tooltip.positioners.bottomPositioner = function (items) {
        const pos = Chart.Tooltip.positioners.average(items);
        if (pos === false) {
          return false;
        }
        const chart = this.chart;
        return {
          x: pos.x,
          y: chart.chartArea.bottom,
          xAlign: "center",
          yAlign: "bottom",
        };
      };

      const chartAreaBorder = {
        id: "chartAreaBorder",
        beforeDraw(chart, args, options) {
          if (chart.options.plugins.zoom.zoom.wheel.enabled) {
            const {
              ctx,
              chartArea: { left, top, width, height },
            } = chart;
            ctx.save();
            ctx.strokeStyle = options.borderColor;
            ctx.lineWidth = options.borderWidth;
            ctx.setLineDash(options.borderDash || []);
            ctx.lineDashOffset = options.borderDashOffset;
            ctx.strokeRect(left, top, width, height);
            ctx.restore();
          }
        },
      };

      const chartBackgroundColor = {
        id: "customCanvasBackgroundColor",
        beforeDraw: (chart, args, options) => {
          const { ctx } = chart;
          ctx.save();
          ctx.globalCompositeOperation = "destination-over";
          ctx.fillStyle = options.color || "#99ffff";
          ctx.fillRect(0, 0, chart.width, chart.height);
          ctx.restore();
        },
      };

      function download_image(canvas, title) {
        image = canvas.toDataURL("image/png").replace("image/png", "image/octet-stream");
        var link = document.createElement("a");
        link.download = title + ".png";
        link.href = image;
        link.click();
      }

      function newCanvasContext2d(navDisable) {
        const pCanvasList = document.getElementById("pCanvasList");
        const div1 = document.createElement("div");
        const div2 = document.createElement("div");
        const div3 = document.createElement("div");
        const canvas = document.createElement("canvas");
        const divBtn = document.createElement("div");
        const downloadBtn = document.createElement("input");
        const prevBtn = document.createElement("input");
        const nextBtn = document.createElement("input");
        const resetBtn = document.createElement("input");
        div1.className = "d-block w-100";
        div2.className = "card";
        div3.className = "card-body";
        divBtn.className = "card-body row gap-2 justify-content-between";
        divBtn.role = "group";

        prevBtn.className = "btn btn-outline-primary col";
        prevBtn.type = "button";
        prevBtn.value = "Anterior";
        prevBtn.addEventListener("click", () => {
          g_chartUpdate.prev();
        });

        nextBtn.className = "btn btn-outline-primary col";
        nextBtn.type = "button";
        nextBtn.value = "Pr√≥ximo";
        nextBtn.addEventListener("click", () => {
          g_chartUpdate.next();
        });

        if (navDisable) {
          prevBtn.disabled = true;
          nextBtn.disabled = true;
        }

        resetBtn.className = "btn btn-primary col-md-auto";
        resetBtn.type = "button";
        resetBtn.value = "Reset Zoom";
        resetBtn.addEventListener("click", () => {
          g_chartUpdate.resetZoom();
        });

        downloadBtn.className = "btn btn-primary col-md-auto";
        downloadBtn.type = "button";
        downloadBtn.value = "Download";
        downloadBtn.addEventListener("click", () => {
          download_image(canvas, g_chartUpdate.title());
        });

        pCanvasList.appendChild(div1);
        div1.appendChild(div2);
        div2.appendChild(div3);
        div3.appendChild(canvas);
        div3.appendChild(divBtn);
        divBtn.appendChild(prevBtn);
        divBtn.appendChild(resetBtn);
        divBtn.appendChild(downloadBtn);
        divBtn.appendChild(nextBtn);
        return canvas.getContext("2d");
      }

      function createDataset(sensor_data) {
        let datasets = [];
        sensor_data.forEach((bot_name) => {
          sensor_data[bot_name].forEach((sensor, index) => {
            try {
              let data = [];
              sensor_data[bot_name][sensor].forEach((value, index) => {
                if (value.length) {
                  let line = g_default_sensor[index].chart;
                  data.push({
                    type: line.type,
                    hidden: line.hidden,
                    label: line.label,
                    borderColor: line.borderColor,
                    data: value,
                  });
                }
              });
              const title = bot_name + " - " + sensor;
              datasets.push({ datasets: data, title: title });
            } catch (error) {}
          });
        });
        return datasets;
      }

      function createChart(navDisable) {
        let chart = {};
        const ctx = newCanvasContext2d(navDisable);
        try {
          chart = new Chart(ctx, {
            data: {
              datasets: [],
            },
            options: {
              animation: false,
              responsive: true,
              scales: {
                y: {
                  reverse: false,
                  suggestedMin: 0,
                  suggestedMax: 100,
                },
                x: {
                  type: "time",
                  min: g_min_date,
                  max: g_max_date,
                  time: {
                    displayFormats: {
                      day: "d MMM",
                      hour: "d MMM, HH:mm",
                      minute: "d MMM, HH:mm",
                    },
                  },
                },
              },
              interaction: {
                intersect: false,
                axis: "x",
                mode: "nearest",
              },
              plugins: {
                customCanvasBackgroundColor: {
                  color: "rgba(248,248,248,1)",
                },
                tooltip: {
                  position: "bottomPositioner",
                },
                title: {
                  display: true,
                  text: "Gr√°fico",
                },
                zoom: {
                  pan: {
                    enabled: true,
                    mode: "xy",
                    overScaleMode: "xy",
                  },
                  zoom: {
                    drag: {
                      enabled: false,
                      backgroundColor: "rgba(192,192,192,0.3)",
                      modifierKey: "ctrl",
                    },
                    wheel: {
                      enabled: false,
                    },
                    pinch: {
                      enabled: false,
                    },
                    mode: "xy",
                    overScaleMode: "xy",
                  },
                },
                chartAreaBorder: {
                  borderColor: "red",
                  borderWidth: 1,
                  borderDash: [10, 3],
                  borderDashOffset: 5,
                },
              },
              onClick(e) {
                const chart = e.chart;
                const new_state = !chart.options.plugins.zoom.zoom.wheel.enabled;
                chart.options.plugins.zoom.zoom.wheel.enabled = new_state;
                chart.options.plugins.zoom.zoom.pinch.enabled = new_state;
                chart.options.plugins.zoom.zoom.drag.enabled = new_state;
                chart.options.plugins.zoom.pan.enabled = new_state;
                chart.update();
              },
            },
            plugins: [chartBackgroundColor, chartAreaBorder],
          });
        } catch (error) {}
        return chart;
      }

      function createSelector() {
        const pSelector = document.getElementById("pSelector");

        // const p_start = document.createElement("p");
        const input_start = document.createElement("input");
        const label_start = document.createElement("label");

        // const p_end = document.createElement("p");
        const input_end = document.createElement("input");
        const label_end = document.createElement("label");

        label_start.innerHTML = "In√≠cio:";
        label_end.innerHTML = "Fim:";

        input_start.id = "pDataInicial";
        input_end.id = "pDataFinal";

        input_start.type = "datetime-local";
        input_end.type = "datetime-local";

        input_start.className = "input-group mb-3";
        input_end.className = "input-group mb-3";

        input_start.addEventListener("change", () => {
          g_chartUpdate.zoom(input_start.value, input_end.value);
        });
        input_end.addEventListener("change", () => {
          g_chartUpdate.zoom(input_start.value, input_end.value);
        });

        pSelector.appendChild(label_start);
        label_start.appendChild(input_start);

        pSelector.appendChild(label_end);
        label_end.appendChild(input_end);

        updateDateSelector(input_start, input_end);
      }

      function resetElements() {
        const pCanvasList = document.getElementById("pCanvasList");
        while (pCanvasList.hasChildNodes()) {
          pCanvasList.removeChild(pCanvasList.lastChild);
        }
        const event = document.getElementById("pEvents");
        while (event.hasChildNodes()) {
          event.removeChild(event.lastChild);
        }
        const selector = document.getElementById("pSelector");
        while (selector.hasChildNodes()) {
          selector.removeChild(selector.lastChild);
        }
        g_chartUpdate = null;
        g_max_date = undefined;
        g_min_date = undefined;
      }

      class Message {
        constructor(message) {
          if (message.type === "message") {
            this.message = message;
          } else {
            throw "Message type error!";
          }
        }
        text() {
          let text = "";
          this.message.text_entities.forEach((fragment) => {
            text += fragment.text;
          });
          if (text.length) {
            return text;
          } else {
            throw "Text is empty!";
          }
        }
        author() {
          if (typeof this.message.from === "string") {
            if (typeof this.message.author === "string") {
              return this.message.from + " - " + this.message.author;
            } else {
              return this.message.from;
            }
          } else {
            throw "Author error!";
          }
        }
        #number(string) {
          let number = Number.parseFloat(string);
          if (typeof number !== "number" || Number.isNaN(number)) {
            throw "NaN";
          }
          return number;
        }
        #numberAt(string, position) {
          return this.#number(string.substring(position));
        }
        date() {
          return this.#number(this.message.date_unixtime) * 1000;
        }
        #sensorName(line) {
          if (line.startsWith("Nome:")) {
            return line.substring(line.indexOf('"') + 1, line.lastIndexOf('"'));
          } else {
            throw "Message content error!";
          }
        }
        #sensorValue(line) {
          try {
            return this.#numberAt(line, line.indexOf(":") + 1);
          } catch (err) {
            return this.#numberAt(line, line.lastIndexOf("(") + 1);
          }
        }
        parse(filter) {
          let textLines = this.text().split("\n");
          let author = this.author();
          let sensor = this.#sensorName(textLines[0]);
          textLines.shift();
          let date = this.date();
          let values = new Array(filter.length);
          textLines.forEach((line) => {
            filter.forEach((item, index) => {
              try {
                if (line.includes(item)) {
                  values[index] = this.#sensorValue(line);
                }
              } catch (err) {}
            });
          });
          return { author, sensor, date, values };
        }
      }

      function pushEvent(msg) {
        const text = msg.text();
        const author = msg.author();
        const date = luxon.DateTime.fromMillis(msg.date()).toFormat("F");

        const event = document.getElementById("pEvents");
        let pContainer;
        if (event.childElementCount == 0) {
          pContainer = document.createElement("p");
          pContainer.className = "container";
          pContainer.id = "pEventsContainer";
          event.appendChild(pContainer);

          const hEvent = document.createElement("h3");
          hEvent.innerText = "Eventos";
          pContainer.appendChild(hEvent);
        } else {
          pContainer = document.getElementById("pEventsContainer");
        }
        const div = document.createElement("div");
        div.className = "container msg";
        pContainer.appendChild(div);

        const spanAuthor = document.createElement("span");
        spanAuthor.className = "author-left";
        spanAuthor.innerText = author;
        div.appendChild(spanAuthor);

        div.appendChild(document.createElement("br"));

        const pText = document.createElement("p");
        pText.innerText = text;
        div.appendChild(pText);

        const spanDate = document.createElement("span");
        spanDate.className = "time-right";
        spanDate.innerText = date;
        div.appendChild(spanDate);
      }

      function importData(imported) {
        let sensor_data = [];
        const result = JSON.parse(imported);
        let filter = [];
        g_default_sensor.forEach((item) => filter.push(item.parse.key));
        result.messages.forEach((message) => {
          try {
            const msg = new Message(message);
            try {
              const result = msg.parse(filter);
              result.values.forEach((value, index) => {
                pushValue(sensor_data, result.author, result.sensor, index, {
                  x: result.date,
                  y: value,
                });
              });
              registerDate(result.date);
            } catch (err) {
              try {
                pushEvent(msg);
              } catch (err) {}
            }
          } catch (err) {}
        });
        return sensor_data;
      }

      function processJson(imported) {
        resetElements();
        let sensor_data = importData(imported);
        let datasets = createDataset(sensor_data);
        let navDisable = datasets.length < 2;
        let chart = createChart(navDisable);
        g_chartUpdate = new ChartUpdate(datasets, chart);
        createSelector();
      }

      function handleFiles(files) {
        const reader = new FileReader();
        reader.readAsText(files[0]);
        reader.onload = () => {
          try {
            processJson(reader.result);
          } catch (err) {
            console.error(err);
          }
        };
      }
    </script>
    <div class="container-sm">
      <nav class="navbar navbar-expand-lg bg-body-tertiary">
        <div class="text-center">
          <img src="sensor.log.png" width="80%" />
        </div>
        <div class="container-fluid">
          <p></p>
          <ul class="nav nav-pills" role="tablist">
            <li class="nav-item">
              <a class="nav-link active" data-bs-toggle="tab" href="#chart">üìä Gr√°ficos</a>
            </li>
            <li class="nav-item">
              <a class="nav-link" data-bs-toggle="tab" href="#calc1">üìè mm ‚ûõ %</a>
            </li>
            <li class="nav-item">
              <a class="nav-link" data-bs-toggle="tab" href="#calc2">üìè % ‚ûõ mm</a>
            </li>
          </ul>
        </div>
      </nav>

      <!-- Tab panes -->
      <div class="tab-content">
        <div id="chart" class="container tab-pane fade show active">
          <style>
            .msg {
              background-color: #f7f7f7;
            }

            .time-right {
              float: right;
              color: #aaa;
            }

            .author-left {
              font-weight: bold;
              float: left;
              color: #07c3f2;
            }
          </style>
          <p></p>
          <div class="card">
            <div class="card-body">
              <div class="mb-3">
                <label for="pFileInput" class="form-label">Carregue um arquivo:</label>
                <input
                  type="file"
                  class="form-control"
                  id="pFileInput"
                  accept=".json"
                  onchange="handleFiles(this.files)"
                />
              </div>
              <p id="pSelector"></p>
            </div>
          </div>
          <p></p>
          <div id="pCanvasList"></div>
          <p id="pEvents"></p>
        </div>
        <div id="calc1" class="container tab-pane fade">
          <fieldset class="form-group">
            <form id="mm2percent">
              <div class="form-group mb-3">
                <legend>Dist√¢ncia (mm)</legend>
                <label for="mmMillimeter" class="form-label"> </label>
                <input id="mmMillimeter" class="form-control" type="number" value="350" onchange="calculePercent()" />
              </div>
              <div class="form-group mb-3">
                <legend>Offset (mm)</legend>
                <label for="mmOffset" class="form-label"> </label>
                <input id="mmOffset" class="form-control" type="number" value="300" onchange="calculePercent()" />
              </div>
              <div class="form-group mb-3">
                <legend>Bottom (mm)</legend>
                <label for="mmBottom" class="form-label"> </label>
                <input id="mmBottom" class="form-control" type="number" value="1300" onchange="calculePercent()" />
              </div>
              <div class="form-group mb-3">
                <legend>Valor (%)</legend>
                <label for="mmPercent" class="form-label"> </label>
                <input id="mmPercent" class="form-control" value="95" readonly />
              </div>
            </form>
          </fieldset>
        </div>
        <div id="calc2" class="container tab-pane fade">
          <fieldset class="form-group">
            <form id="percent2mm">
              <div class="form-group mb-3">
                <legend>Valor (%)</legend>
                <label for="pPercent" class="form-label"> </label>
                <input id="pPercent" class="form-control" type="number" value="95" onchange="calculeMillimeter()" />
              </div>
              <div class="form-group mb-3">
                <legend>Offset (mm)</legend>
                <label for="pOffset" class="form-label"> </label>
                <input id="pOffset" class="form-control" type="number" value="300" onchange="calculeMillimeter()" />
              </div>
              <div class="form-group mb-3">
                <legend>Bottom (mm)</legend>
                <label for="pBottom" class="form-label"> </label>
                <input id="pBottom" class="form-control" type="number" value="1300" onchange="calculeMillimeter()" />
              </div>
              <div class="form-group mb-3">
                <legend>Dist√¢ncia (mm)</legend>
                <label for="pMillimeter" class="form-label"> </label>
                <input id="pMillimeter" class="form-control" value="350" readonly />
              </div>
            </form>
          </fieldset>
        </div>
      </div>
    </div>
  </body>
</html>
